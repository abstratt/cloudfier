package com.abstratt.mdd.target.jee

import com.abstratt.kirra.InstanceRef
import com.abstratt.kirra.TypeRef
import com.abstratt.mdd.core.IRepository
import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.node.ObjectNode
import com.fasterxml.jackson.databind.node.TextNode
import java.util.LinkedHashSet
import java.util.Map
import java.util.Set
import java.util.concurrent.atomic.AtomicLong
import org.eclipse.uml2.uml.Class
import org.eclipse.uml2.uml.Property

import static extension com.abstratt.kirra.mdd.core.KirraHelper.*

class DataSnapshotJoinedTableGenerator extends DataSnapshotGenerator {
	Map<String, Long> idMapping = newLinkedHashMap()
	
	new(IRepository repository) {
		super(repository)
	}

	/**
	 * In this strategy, a single instance is mapped to potentially many database rows, one
	 * per table representing each class (concrete or abstract) in the hierarchy.
	 * 
	 * Note that when an instance is broken up into multiple rows, each row will have the same
	 * PK. The id is the one defined for the base class.
	 */
	def override Iterable<CharSequence> generateInstance(Class entity, String namespace, String className, long index,
		ObjectNode node, Map<String, AtomicLong> ids) {
		val id = generateId(entity, index, ids)
		println('''«entity.qualifiedName» =  «id»''')
		
		val hierarchy = findHierarchy(entity)

		val propertiesPerEntity = hierarchy.map[qualifiedName].toInvertedMap[newArrayList]
		val allEntityProperties = entity.properties.filter[!autoGenerated]
		allEntityProperties.forEach [
			val collection = propertiesPerEntity.get(it.class_.qualifiedName)
			collection.add(it)
		]

		val relationshipsPerEntity = hierarchy.map[qualifiedName].toInvertedMap[newArrayList]
		val allEntityRelationships = entity.entityRelationships.filter[!derived && primary && !multivalued]
		allEntityRelationships.forEach [
			relationshipsPerEntity.get(it.class_.qualifiedName).add(it)
		]

		return hierarchy.toList.reverseView.map [ current |
			val entityProperties = propertiesPerEntity.get(current.qualifiedName)
			val entityRelationships = relationshipsPerEntity.get(current.qualifiedName)
			generateInsert(entityProperties, entityRelationships, node, current.name, id)
		]
	}
	
	def generateId(Class entity, long index, Map<String, AtomicLong> ids) {
		val newId = ids.get(findRootClass(entity).qualifiedName).incrementAndGet()
		idMapping.put(TypeRef.sanitize(entity.qualifiedName) + "@" + index, newId)
		return newId
	}
	
	override def CharSequence getRelatedInstanceId(Property relationship, JsonNode propertyValue) {
		val originalReferenceString = (propertyValue as TextNode).textValue
		println("idMapping=" + idMapping)
		println("referenceString=" + originalReferenceString)
		
		// if the type is not qualified, do it
		val ref = InstanceRef.parse(originalReferenceString, relationship.nearestPackage.name) 
		val referenceString = ref.toString()
		return "" + idMapping.get(referenceString)
	}	
	
	override def Iterable<String> generateAlterSequences(Map<String, AtomicLong> ids, String namespace, Map<String, Class> entities) {
		return ids.entrySet.filter[!entities.get(it.key).superClasses.exists[it.entity]].map [ pair |
			val entity = entities.get(pair.key)
			val nextValue = pair.value.get + 1
			'''«generateAlterSequenceStatement(namespace, entity, nextValue)»'''
		]
	}
	
	def Class findRootClass(Class entity) {
		val superClasses = entity.superClasses.filter[it.entity]
		if (superClasses.empty)
			return entity
		if (superClasses.size > 1)
			throw new IllegalStateException('''Multiple base classes found: «superClasses.map[qualifiedName].join(', ')» for «entity.qualifiedName»''')
		return findRootClass(superClasses.get(0))
	}

	def Iterable<Class> findHierarchy(Class entity) {
		val superClasses = entity.superClasses.filter[it.entity]
		if (superClasses.empty)
			return #[entity]
		if (superClasses.size > 1)
			throw new IllegalStateException('''Multiple base classes found: «superClasses.map[qualifiedName].join(', ')» for «entity.qualifiedName»''')
		return #[entity] + findHierarchy(superClasses.get(0))
	}

	private def findRootSuperClass(Class entity) {
		val allSuperClasses = collectAllSuperClasses(entity, newLinkedHashSet())
		val candidates = new LinkedHashSet(allSuperClasses)
		allSuperClasses.forEach [
			if(it.superClasses.exists[superSuperClass|superClasses.contains(superSuperClass)]) candidates.remove(it)
		]
		if (candidates.size() >
			1)
			throw new IllegalStateException('''Multiple base classes found: «candidates.map[qualifiedName].join(', ')» for «entity.qualifiedName»''')
		val rootSuperClass = if(candidates.empty) null else candidates.iterator.next
		return rootSuperClass
	}

	def private Set<Class> collectAllSuperClasses(Class current, Set<Class> collected) {
		val superClasses = current.superClasses
		collected.addAll(superClasses)
		superClasses.forEach[collectAllSuperClasses(it, collected)]
		return collected
	}

}
